#!/usr/bin/env bash

# All available global variables
# Naming convention:
	# Variables should be __<name>__
	# Directory should be __<name>_dir__
	# Exec file should be __<name>_exec__
# Variables
set -e
export ENVROOT=$(cd $(dirname $0) && pwd)
export CLI_VERSION=$(cat $ENVROOT/VERSION)
export __profile__="default"

# Directory
set -e
export __profiles_dir__=$ENVROOT/etc/profiles
export __var_log_dir__=$ENVROOT/var/log
export __var_lib_dir__=$ENVROOT/var/lib
export __var_mail_dir__=$ENVROOT/var/mail

# bin/**
set -e
export __docker_exec__=$ENVROOT/bin/docker
export __profile_exec__=$ENVROOT/bin/profile
export __log__=$ENVROOT/bin/log

usage() {
	cli_name=${0##*/}
	echo "
$cli_name
your env CLI
version: $CLI_VERSION
usage: $cli_name [options] [command [command's options]]

options:
    -p | --profile :  	Profile that cli with take action on.
                  		Avoiding conflict data, accidentally delete dev data when running test.

commands:
    docker    			Up and running dockers container
              			All possible containers a listed in etc/docker
              			Will create volume for corresponding containers in proc/<ENV>/docker

	profile				Config profile.

    *         			Help.
"
	exit 1
}

# Handle the environment settings
# Default environment will be dev
# Use options -e | --env to set environment
# Only accept dev | test
set -e
export ENV='dev'

env() {
	ENV=$1

	if [[ -z "$ENV" ]]; then
		ENV="dev"
	fi

	if [[ "$ENV" != "dev" ]] && [[ "$ENV" != "test" ]]; then
		echo "-e only accept values ['dev', 'test']"
		exit 1
	fi

	set -e
	export ENV="$ENV"
}

while [ "$1" != "" ]; do
	case $1 in
	-e | --env)
		shift
		env $1
		;;

	docker)
		shift
		$__log__ -i "CLI taking action on ENV: $ENV"
		$__docker_exec__ $@
		exit
		;;

	profile)
		shift
		$__profile_exec__ $@
		exit
		;;

	-h | --help)
		usage
		exit
		;;

	*)
		usage
		exit 1
		;;
	esac
	shift
done
