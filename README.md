# env ![](https://github.com/luanphandinh/env/workflows/workspace/badge.svg) ![](https://github.com/luanphandinh/env/workflows/cli/badge.svg)
Easy, clean and faster way to spin up docker containers: mysql, adminer, es, rabbitmq, ...\
Seprate profile and highly confirgurable.

## install
clone this project to anywhwere in your computer, then `cd <path_to_project>`
```bash
make install
```
`cli` is the `alias` refer to `<path_to_project>/cli.sh` file, if the `make install` command doesn't include the `alias cli -> <path_to_project>/cli.sh`, you could create alias on your own.

## help
```bash
cli -h
cli docker -h
```

## docker
run:
```
cli docker run mysql adminer
```
The command above will look into `./env/etc/docker/` and find `mysql.yaml`, `adminer.yaml` and use `docker-compose` to start docker services.

run with profile (`cli -p <profile_name> docker run mysql adminer`):
```
cli -p new_to_env docker run mysql adminer
```

Add new docker-compose file that not existed in current repository\
Simply add `<service_name>.yml` into `env/etc/docker`.\
```
cli/etc
  |__docker
  |     |__ .PORTS          // This file content all the default PORTS that will be used accross all dockers config file
  |     |__mysql.yaml
  |     |__adminer.yaml
  |
  |__profile
  |     |__default
  |     |   |__ .env
  |     |__ new_to_env
  |     |   |__ .env
```

example file (`etc/docker/mysql.yaml`):
```yaml
version: '3.3'

services:
  mysql:
    container_name: "${__DOCKER_SERVICE_PREFIX__}_mysql"
    hostname: "${__DOCKER_SERVICE_PREFIX__}_mysql"
    image: mysql
    volumes:
      - '${__DOCKER_PATH__}/mysql:/var/lib/mysql'
    command:
      - --default-authentication-plugin=mysql_native_password
    environment:
      MYSQL_ROOT_PASSWORD: rootroot
      MYSQL_DATABASE: workspace
      MYSQL_USER: admin
      MYSQL_PASSWORD: admin
    ports:
      - ${MYSQL_PORT}:3306
```

configs:
* `__DOCKER_PATH__` refer to `var/lib/docker/<current_profile>/`\
Highly recommended to use this path, it allows you to seperate your runtime data with profile
* `__DOCKER_DIR__` refer to current config path `env/etc/docker/`
If you want to bind some config that will be reused and not seperate by profile, could be put them into this place\
Seem more at `env/etc/docker/vault.yaml`
* `__DOCKER_SERVICE_PREFIX__` auto generated by cli, value as `docker_<profile_name>_<service_name>`
* `*_PORTS` can be found under `env/etc/docker/.PORTS`.\
Highly recommend your new service has default dynamic env binding port to outside, as it will be easier to running with profiles later

## Profile

set:
```
cli -p new_to_env set ADMINER_PORT=4444
```

Then run docker service with profile:
```
cli -p new_to_env docker run adminer
```
This will up and running `cli_new_to_env_adminer` container on port `4444`, cause the profile override the default `ADMINER_PORT=4000`

run:
```
cli -p new_to_env run npm run dev
```

Suppose you have service written in javascript, you can facilitate using profile with all its `.env` config and apply to process that run `npm run dev`.

## Config file:
```bash
cli.sh up config.dev.yaml
```

```yaml
import_profile: service
env:
  - ADMINER_PORT=5555
dockers:
  - redis
  - adminer

services:
  - node
  - php
  # - not_run

service:
  node:
    import_profile: pt
    env:
      - NAME=CLI
      - SAY=Bonjour
    path: $__ENV_ROOT__/test/
    run: node ./service.js
  php:
    env:
      - SAY=Bonjour
      - NAME=CLI_PHP
    path: $__ENV_ROOT__/test/
    run: php -S localhost:8080 router.php
  not_run:
    env:
      - SAY=This should not be running
      - NAME=CLI_PHP
    path: $__ENV_ROOT__/somewhere/
    run: php -S localhost:8080 router.php
  # also_not_run:
    # env:
      # - SAY=This should not be running
      # - NAME=CLI_PHP
    # path: $__ENV_ROOT__/somewhere/
    # run: php -S localhost:8080 router.php
```

env scope:
`default (.PORTS) -> profile(etc/config/<profile>/.env) -> [env] from config file`
