# env ![](https://github.com/luanphandinh/env/workflows/workspace/badge.svg) ![](https://github.com/luanphandinh/env/workflows/cli/badge.svg)
Easy, clean and faster way to spin up docker containers: mysql, adminer, es, rabbitmq, ...\
Seprate profile and highly confirgurable.

# install
```bash
make install
source ~/.bash_profile
```

# help
```bash
cli -h
cli docker -h
```

# docker
## run
```
./cli.sh docker run mysql adminer
```

## run with profile (`./cli.sh -p <profile_name> docker run mysql adminer`):
```
./cli.sh -p new_to_env docker run mysql adminer
```

```
cli/etc
  |__docker
  |     |__ .PORTS          // This file content all the default PORTS that will be used accross all dockers config file
  |     |__mysql.yaml
  |     |__adminer.yaml
  |
  |__profile
  |     |__default
  |     |   |__ .env
  |     |__ new_to_env
  |     |   |__ .env
```

To add and running new docker container that not existed in current repository\
You can simply add `<service_name>.yml` into `env/etc/docker`.\

## example:
```yaml
version: '3.3'

services:
  mysql:
    container_name: "${__DOCKER_SERVICE_PREFIX__}_mysql"
    hostname: "${__DOCKER_SERVICE_PREFIX__}_mysql"
    image: mysql
    volumes:
      - '${__DOCKER_PATH__}/mysql:/var/lib/mysql'
    command:
      - --default-authentication-plugin=mysql_native_password
    environment:
      MYSQL_ROOT_PASSWORD: rootroot
      MYSQL_DATABASE: workspace
      MYSQL_USER: admin
      MYSQL_PASSWORD: admin
    ports:
      - ${MYSQL_PORT}:3306
```

## configs:
* `__DOCKER_PATH__` refer to `var/lib/docker/<current_profile>/`\
Highly recommended to use this path, it allows you to seperate your runtime data with profile
* `__DOCKER_DIR__` refer to current config path `env/etc/docker/`
If you want to bind some config that will be reused and not seperate by profile, could be put them into this place\
Seem more at `env/etc/docker/vault.yaml`
* `__DOCKER_SERVICE_PREFIX__` auto generated by cli, value as `docker_<profile_name>_<service_name>`
* `*_PORTS` can be found under `env/etc/docker/.PORTS`.\
Highly recommend your new service has default dynamic env binding port to outside, as it will be easier to running with profiles later

# Profile

## set
```
./cli.sh -p new_to_env set ADMINER_PORT=4444
```

Then run docker service with profile
```
./cli.sh -p new_to_env docker run adminer
```
This will up and running `cli_new_to_env_adminer` container on port `4444`, cause the profile override the default `ADMINER_PORT=4000`

## run
```
# given you alias /path/to/env/cli.sh with cli.
cli -p new_to_env run npm run dev
```

Suppose you have service written in javascript, you can facilitate using profile with all its `.env` config and apply to process that run `npm run dev`.

# Config file
```txt
# config.dev.txt
[profile:runner]

[env]
REDIS_PORT=9999

[dockers: redis redis-commander mysql adminer]
```
run:

```bash
./cli.sh up config.dev.txt
```

env scope:
`default (.PORTS) -> profile(etc/config/<profile>/.env) -> [env] from config file`
